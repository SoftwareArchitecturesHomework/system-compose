<!DOCTYPE html>
<html>
<head>
<title>documentation.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<center>
</center><h1 id="szoftverarchitekt%C3%BAr%C3%A1k-h%C3%A1zi-feladat-dokument%C3%A1ci%C3%B3brc%C3%A9ges-munkaid%C5%91-napl%C3%B3">Szoftverarchitektúrák házi feladat dokumentáció<br>Céges munkaidő napló</h1>
<br>
<br>
<br>
<p><img src="file:///home/wingsmc/dev/bme/arch/core-app/public/logo-light.png" alt="logo"></p>
<br>
<br>
<br>
<br>
<br>
<br>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Farkas Fanni</td>
<td>EU7XYP</td>
</tr>
<tr>
<td>Bertók Dániel</td>
<td>H01HRM</td>
</tr>
<tr>
<td>Dremák Gergely</td>
<td>KSHSLY</td>
</tr>
<tr>
<td>Forrás Máté Ákos</td>
<td>ONQ3KU</td>
</tr>
</tbody>
</table>

<hr>
<ul>
<li><a href="#szoftverarchitekt%C3%BAr%C3%A1k-h%C3%A1zi-feladat-dokument%C3%A1ci%C3%B3c%C3%A9ges-munkaid%C5%91-napl%C3%B3">Szoftverarchitektúrák házi feladat dokumentációCéges munkaidő napló</a>
<ul>
<li><a href="#rendszer-c%C3%A9lja-%C3%A9s-k%C3%B6rnyezete">Rendszer célja és környezete</a>
<ul>
<li><a href="#feladatki%C3%ADr%C3%A1s">Feladatkiírás</a></li>
<li><a href="#funkci%C3%B3k">Funkciók</a></li>
<li><a href="#rendszer-k%C3%B6rnyezete">Rendszer környezete</a></li>
</ul>
</li>
<li><a href="#architekt%C3%BAra">Architektúra</a>
<ul>
<li><a href="#architekt%C3%BAra-%C3%A1ttekint%C3%A9se">Architektúra áttekintése</a></li>
<li><a href="#architekt%C3%BAr%C3%A1lis-d%C3%B6nt%C3%A9sek-%C3%A9s-indokl%C3%A1suk">Architektúrális döntések és indoklásuk</a>
<ul>
<li><a href="#microservice-architekt%C3%BAra">Microservice architektúra</a></li>
<li><a href="#rest-api-kommunik%C3%A1ci%C3%B3">REST API kommunikáció</a></li>
<li><a href="#nuxt-full-stack-keretrendszer">NUXT full-stack keretrendszer</a></li>
<li><a href="#postgresql-adatb%C3%A1zis">PostgreSQL adatbázis</a></li>
<li><a href="#jwt-alap%C3%BA-autentik%C3%A1ci%C3%B3">JWT alapú autentikáció</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#r%C3%A9tegek-le%C3%ADr%C3%A1sa">Rétegek leírása</a>
<ul>
<li><a href="#adatb%C3%A1zis-r%C3%A9teg-database-layer">Adatbázis réteg (Database Layer)</a></li>
<li><a href="#repository-r%C3%A9teg-data-access-layer">Repository réteg (Data Access Layer)</a></li>
<li><a href="#service-r%C3%A9teg-business-logic-layer">Service réteg (Business Logic Layer)</a></li>
<li><a href="#api-r%C3%A9teg-route-handlers">API réteg (Route Handlers)</a></li>
<li><a href="#authentication-r%C3%A9teg">Authentication réteg</a></li>
<li><a href="#prezent%C3%A1ci%C3%B3s-r%C3%A9teg-frontend">Prezentációs réteg (Frontend)</a></li>
<li><a href="#r%C3%A9tegek-k%C3%B6z%C3%B6tti-kommunik%C3%A1ci%C3%B3">Rétegek közötti kommunikáció</a></li>
</ul>
</li>
<li><a href="#microsevice-ek">Microsevice-ek</a>
<ul>
<li><a href="#comms-szolg%C3%A1ltat%C3%A1s--elixirphoenix">Comms Szolgáltatás – (Elixir/Phoenix)</a>
<ul>
<li><a href="#1-c%C3%A9l-%C3%A9s-hat%C3%B3k%C3%B6r">1. Cél és Hatókör</a></li>
<li><a href="#2-f%C5%91-%C3%B6sszetev%C5%91k">2. Fő Összetevők</a>
<ul>
<li><a href="#email">E‑mail</a></li>
<li><a href="#discord">Discord</a></li>
</ul>
</li>
<li><a href="#3-adat-%C3%A9s-sablonkezel%C3%A9s">3. Adat és Sablonkezelés</a></li>
<li><a href="#4-folyamatok">4. Folyamatok</a>
<ul>
<li><a href="#email-k%C3%BCld%C3%A9s">E‑mail Küldés</a></li>
<li><a href="#discord-interaction">Discord Interaction</a></li>
<li><a href="#discord-command-telep%C3%ADt%C3%A9s">Discord Command Telepítés</a></li>
</ul>
</li>
<li><a href="#5-hibakezel%C3%A9s">5. Hibakezelés</a></li>
<li><a href="#6-biztons%C3%A1g">6. Biztonság</a></li>
<li><a href="#7-egyszer%C5%B1-metrik%C3%A1k--logok-aktu%C3%A1lis-%C3%A1llapot">7. Egyszerű Metrikák / Logok (Aktuális Állapot)</a></li>
<li><a href="#8-tesztek">8. Tesztek</a></li>
</ul>
</li>
<li><a href="#reporting-service-python">Reporting Service (Python)</a></li>
</ul>
</li>
<li><a href="#telep%C3%ADt%C3%A9si-le%C3%ADr%C3%A1s">Telepítési leírás</a>
<ul>
<li><a href="#development">Development</a>
<ul>
<li><a href="#futtat%C3%A1s-fejleszt%C5%91i-m%C3%B3dban">Futtatás fejlesztői módban:</a>
<ul>
<li><a href="#core-application">Core Application</a></li>
<li><a href="#communications-service">Communications Service</a></li>
<li><a href="#reporting-service">Reporting Service</a></li>
</ul>
</li>
<li><a href="#adatb%C3%A1zis">Adatbázis</a></li>
</ul>
</li>
<li><a href="#production">Production</a>
<ul>
<li><a href="#el%C5%91k%C3%A9sz%C3%BCletek-">Előkészületek :</a></li>
<li><a href="#postgresql-adatb%C3%A1zis-1">PostgreSQL adatbázis:</a></li>
<li><a href="#coremigratorreporting-szolg%C3%A1ltat%C3%A1sok">Core/Migrator/Reporting szolgáltatások:</a></li>
<li><a href="#migrator">Migrator:</a></li>
<li><a href="#core-application-nuxt">Core Application (Nuxt):</a></li>
<li><a href="#communications-service-elixirphoenix">Communications Service (Elixir/Phoenix):</a></li>
<li><a href="#reporting-service-python-1">Reporting Service (Python):</a></li>
</ul>
</li>
<li><a href="#deployment">Deployment</a>
<ul>
<li><a href="#futtat%C3%A1s-lok%C3%A1lisan-buildelt-image-ekkel">Futtatás lokálisan buildelt image-ekkel:</a></li>
<li><a href="#futtat%C3%A1s-docker-hubos-image-ekkel">Futtatás Docker Hubos image-ekkel:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="rendszer-c%C3%A9lja-%C3%A9s-k%C3%B6rnyezete">Rendszer célja és környezete</h2>
<h3 id="feladatki%C3%ADr%C3%A1s">Feladatkiírás</h3>
<p>A projekt célja egy olyan munkaidő napló webes alkalmazás létrehozása, amely megkönnyíti a projektek menedzselését, és azokról statisztikákat állít elő egy vállalat dolgozói számára.
A rendszerben felvehetőek projektek, amelyeknek van egy kezdési, és lehet egy tervezett befejezési dátuma. Ezek a projektek megtekinthetőek egy naptár nézetben, illetve az alkalmazottak minden eseményükhöz (pl. megbeszélés, feladatok) rögzíthetik, hogy melyik projekttel foglalkoztak. Emellett a dolgozók a naptárba felvehetik a tervezett szabadnapjaikat, amelyeket a közvetlen felettesüknek kell jóváhagynia.
A felettesek megnézhetik a beosztottjaik jóváhagyásra váró szabadnapjait, illetve amikor azok felvételre kerülnek a naptárba, arról E-Mail értesítést is kapnak. Opcionális célunk, hogy E-Mail mellett más értesítési formák is megvalósításra kerüljenek, elsősorban Discord értesítés formájában.</p>
<h3 id="funkci%C3%B3k">Funkciók</h3>
<ul>
<li><strong>Projektek kezelése</strong>
<ul>
<li>Új projekt létrehozása (név, kezdési dátum, tervezett befejezési dátum)</li>
<li>Projektek megtekintése (lista és részletes nézet)</li>
<li>Résztvevők hozzáadása a projekthez</li>
<li>Résztvevők eltávolítása a projektből</li>
<li>Projekt lezárása (tényleges befejezési dátum rögzítése)</li>
</ul>
</li>
<li><strong>Feladatok kezelése</strong>
<ul>
<li>Feladat létrehozása projekthez rendelten
<ul>
<li>Discord integrációval: slash commandok segítségével is</li>
</ul>
</li>
<li>Feladat részleteinek megtekintése</li>
<li>Feladat hozzárendelése dolgozóhoz
<ul>
<li>Discord integrációval: slash commandok segítségével is</li>
</ul>
</li>
<li>Feladat hozzárendelés módosítása vagy törlése</li>
<li>Feladat státuszának változtatása (befejezett/folyamatban)</li>
<li>Feladat törlése (csak létrehozó által)</li>
</ul>
</li>
<li><strong>Munkaidő nyilvántartás</strong>
<ul>
<li>Munkaidő bejegyzések rögzítése feladatokhoz</li>
<li>Rögzített adatok: dátum, óraszám, megjegyzés</li>
<li>Munkaidő bejegyzések megtekintése</li>
<li>Saját munkaidő bejegyzések törlése</li>
</ul>
</li>
<li><strong>Megbeszélések</strong>
<ul>
<li>Megbeszélés létrehozása</li>
<li>Résztvevők hozzáadása a megbeszéléshez</li>
<li>Kezdési és befejezési időpont megadása</li>
</ul>
</li>
<li><strong>Szabadságok kezelése</strong>
<ul>
<li>Szabadság igénylés létrehozása</li>
<li>Szabadság jóváhagyása vagy elutasítása (menedzser által)</li>
<li>Jóváhagyásra váró szabadságok listázása</li>
</ul>
</li>
<li><strong>Adminisztrációs felület (csak menedzsereknek)</strong>
<ul>
<li>Dolgozók munkaidő adminisztrációjának megtekintése</li>
<li>Szűrés év és hónap alapján</li>
<li>Adminisztrált órák és kötelező órák összehasonlítása</li>
<li>Szabadságok figyelembevétele a kötelező órákból</li>
<li>Státusz jelzés (elegendő/hiányos/nincs bejegyzés)</li>
</ul>
</li>
<li><strong>Naptár nézet</strong>
<ul>
<li>Meetingek, szabadságok és események megtekintése a naptárban</li>
<li>Új meeting hozzáadása és módosítása</li>
<li>Új szabadság hozzáadása és módosítása</li>
<li>Új esemény hozzáadása és módosítása</li>
</ul>
</li>
<li><strong>Felhasználói rendszer</strong>
<ul>
<li>Bejelentkezés Google OAuth-al</li>
<li>Bejelentkezés email és jelszóval</li>
<li>Szerepkör alapú jogosultságkezelés (Menedzser, Alkalmazott)</li>
</ul>
</li>
<li><strong>Értesítések</strong>
<ul>
<li>Email értesítések szabadság igénylésekről</li>
</ul>
</li>
<li><strong>Riportok</strong>
<ul>
<li>HTML és PDF kiterjesztésű riportok megtekintése, letöltése</li>
</ul>
</li>
</ul>
<h3 id="rendszer-k%C3%B6rnyezete">Rendszer környezete</h3>
<p>A rendszer egy modern webes alkalmazás, amely három fő komponensből áll. A központi alkalmazás egy Nuxt alapú full-stack web alkalmazás, amely a felhasználói felületet (Vue komponensek), az üzleti logikát és az API végpontokat egyaránt tartalmazza. Az alkalmazás PostgreSQL relációs adatbázist használ az adatok tárolására, amely Prisma ORM segítségével kerül elérésre.</p>
<p>A hitelesítés NextAuth (Auth.js) könyvtárral van megvalósítva, amely támogatja mind a Google és Discord OAuth alapú bejelentkezést, mind az email-jelszó páros hitelesítést. A munkamenetek JWT tokenekkel vannak kezelve, biztosítva a biztonságos felhasználói azonosítást. A rendszer szerepkör alapú hozzáférés-vezérlést (RBAC) implementál, két szerepkörrel: Menedzser és Alkalmazott.</p>
<p>Az értesítési szolgáltatásokat egy Elixir nyelven írt microservice kezeli, amely felelős az email és Discord értesítések kiküldéséért. Emellett egy Python alapú microservice gondoskodik a riportok és statisztikák generálásáról. A három komponens REST API-kon keresztül kommunikál egymással.</p>
<p>A rendszer Docker compose-al futtatható, megkönnyítve a fejlesztést és a telepítést. A frontend modern, reszponzív felületet biztosít Nuxt UI komponenskönyvtár és TailwindCSS segítségével, támogatva a világos és sötét témákat is.</p>
<h2 id="architekt%C3%BAra">Architektúra</h2>
<h3 id="architekt%C3%BAra-%C3%A1ttekint%C3%A9se">Architektúra áttekintése</h3>
<p>A rendszer microservice alapú architektúrát követ, amely három fő komponensből áll:</p>
<ol>
<li><strong>Core Application</strong> (Nuxt) - Központi webes alkalmazás</li>
<li><strong>Communications Service</strong> (Elixir/Phoenix) - Értesítési microservice</li>
<li><strong>Reporting Service</strong> (Python) - Riportgeneráló microservice</li>
</ol>
<pre><code class="language-mermaid"><div class="mermaid">graph LR

User["Users / Frontend Clients"]


CoreAPI["Core Application (Nuxt.js)"]


subgraph Micro["Microservices"]
    Comms["Communications Service"]
    Reporting["Reporting Service"]
end

subgraph DB["Database"]
    Postgres["PostgreSQL"]
end

subgraph Outside["Outside context"]
    Email["SMTP Email Service"]
    Discord["Discord"]
end

User --> CoreAPI
CoreAPI --> Comms
Comms --> CoreAPI
Comms --> Email
Comms --> Discord
Discord --> Comms
User --> Reporting
CoreAPI --> Postgres
Reporting --> Postgres

</div></code></pre>
<h3 id="architekt%C3%BAr%C3%A1lis-d%C3%B6nt%C3%A9sek-%C3%A9s-indokl%C3%A1suk">Architektúrális döntések és indoklásuk</h3>
<h4 id="microservice-architekt%C3%BAra">Microservice architektúra</h4>
<p>A rendszer microservice alapú felépítést követ, amely az alábbi előnyöket nyújtja:</p>
<p><strong>Szeparált felelősségek</strong>: Minden microservice egy konkrét üzleti funkciót lát el (értesítések, riportok), amely egyszerűsíti a karbantartást és fejlesztést.</p>
<p><strong>Technológiai függetlenség</strong>: Minden szolgáltatás a feladatköréhez jól passzoló technológiával készült:</p>
<ul>
<li><strong>Elixir/Phoenix</strong> az értesítési szolgáltatáshoz - kiváló konkurencia kezelés, hibatűrés</li>
<li><strong>Python</strong> a riportgeneráláshoz - gazdag adatelemző és statisztikai könyvtárak (pandas, matplotlib)</li>
<li><strong>Nuxt</strong> a core alkalmazáshoz - teljes stack fejlesztés egyetlen keretrendszerben</li>
</ul>
<p><strong>Skálázhatóság</strong>: A komponensek egymástól függetlenül skálázhatók. Például az értesítési szolgáltatás külön skálázható nagy terhelés esetén.</p>
<p><strong>Hibatűrés</strong>: Egy microservice hibája nem okozza a teljes rendszer leállását. Ha a riportgeneráló szolgáltatás nem érhető el, a core funkciók továbbra is működnek.</p>
<h4 id="rest-api-kommunik%C3%A1ci%C3%B3">REST API kommunikáció</h4>
<p>A microserviceek közötti kommunikációhoz REST API-kat választottunk:</p>
<p><strong>Egyszerűség</strong>: A REST jól ismert, széles körben támogatott protokoll, amely megkönnyíti az integrációt.</p>
<p><strong>Stateless kommunikáció</strong>: Minden kérés független, ami egyszerűsíti a rendszer állapotkezelését.</p>
<p><strong>Platform függetlenség</strong>: Bármilyen HTTP kliens képes kommunikálni a szolgáltatásokkal.</p>
<h4 id="nuxt-full-stack-keretrendszer">NUXT full-stack keretrendszer</h4>
<p>A core alkalmazáshoz a Nuxt.js-t választottuk:</p>
<p><strong>Unified codebase</strong>: Frontend és backend azonos nyelvben (TypeScript/JavaScript), csökkentve a kontextusváltást.</p>
<p><strong>Server-Side Rendering (SSR)</strong>: Jobb SEO és gyorsabb kezdeti oldalbetöltés.</p>
<p><strong>File-based routing</strong>: Az API végpontok és oldalak könyvtárstruktúrán alapuló routing-ja egyszerűsíti a fejlesztést.</p>
<p><strong>Auto-imports</strong>: Automatikus importálás csökkenti a boilerplate kódot.</p>
<p><strong>Type safety</strong>: TypeScript támogatás az egész stacken keresztül.</p>
<h4 id="postgresql-adatb%C3%A1zis">PostgreSQL adatbázis</h4>
<p>Relációs adatbázist választottunk az alábbi okok miatt:</p>
<p><strong>ACID tulajdonságok</strong>: Tranzakciós biztonság kritikus a munkaidő-nyilvántartásnál.</p>
<p><strong>Komplex kapcsolatok</strong>: A rendszerben számos entitás áll kapcsolatban (felhasználók, projektek, feladatok, munkaidő bejegyzések).</p>
<p><strong>Strukturált adatok</strong>: Az adatok sémája jól definiált és stabil.</p>
<p><strong>Prisma ORM integráció</strong>: Type-safe adatbázis hozzáférés, automatikus migrációk.</p>
<h4 id="jwt-alap%C3%BA-autentik%C3%A1ci%C3%B3">JWT alapú autentikáció</h4>
<p>A munkamenet kezeléshez JWT tokeneket használunk:</p>
<p><strong>Microservice kompatibilitás</strong>: A tokenek könnyen validálhatók a különböző szolgáltatásokban.</p>
<p><strong>CredentialsProvider támogatás</strong>: Lehetővé teszi mind az OAuth, mind az email-jelszó alapú bejelentkezést.</p>
<p><strong>Biztonságos</strong>: A tokenek aláírva tartalmazzák a felhasználói információkat, határozott élettartammal.</p>
<h2 id="r%C3%A9tegek-le%C3%ADr%C3%A1sa">Rétegek leírása</h2>
<p>A Core Application többrétegű architektúrát követ, amely egyértelműen elkülöníti a különböző felelősségeket. Az alkalmazás rétegei alulról felfelé:</p>
<h3 id="adatb%C3%A1zis-r%C3%A9teg-database-layer">Adatbázis réteg (Database Layer)</h3>
<p>Ez a legalsó réteg, amely a PostgreSQL adatbázist tartalmazza. A Prisma ORM biztosítja az adatbázis séma kezelését és a migrációkat. Az adatbázis tárolja az összes perzisztens adatot: felhasználókat, projekteket, feladatokat, munkaidő bejegyzéseket és egyéb entitásokat.</p>
<p><strong>Prisma séma</strong> (<code>/prisma/schema.prisma</code>):</p>
<ul>
<li>Típusbiztos adatmodell definíciók</li>
<li>Kapcsolatok és constraint-ek definiálása</li>
<li>Automatikus migráció generálás</li>
<li>Automatikus seedelés biztosítása fejlesztéshez</li>
</ul>
<p><strong>Adatmodell (Entity-Relationship Diagram)</strong>:</p>
<pre><code class="language-mermaid"><div class="mermaid">erDiagram
  USER {
    int id PK
    string email
    string password
    string name
    string image
    datetime emailVerified
    int managerId FK
    string role
  }

  ACCOUNT {
    int id PK
    int userId FK
    string type
    string provider
    string providerAccountId
    string refresh_token
    string access_token
    int expires_at
    string token_type
    string scope
    string id_token
    string session_state
  }

  SESSION {
    int id PK
    string sessionToken
    int userId FK
    datetime expires
  }

  VERIFICATIONTOKEN {
    string identifier
    string token PK
    datetime expires
  }

  PROJECT {
    int id PK
    string name
    datetime startDate
    datetime endDate
    datetime plannedEndDate
    int ownerId FK
  }

  USERPROJECT {
    int userId FK
    int projectId FK
  }

  TASK {
    int id PK
    string type
    int creatorId FK
    datetime createdAt
    string name
    datetime startDate
    datetime endDate
    string description
    int projectId FK
    int assigneeId FK
    datetime dueDate
    bool isDone
    bool isApproved
  }

  MEETINGPARTICIPANT {
    int id PK
    int meetingId FK
    int userId FK
  }

  TIMEENTRY {
    int id PK
    int taskId FK
    int userId FK
    datetime date
    float hours
    string note
  }

  %% Self-relation: manager ↔ employees
  USER ||--o{ USER : "manages (managerId)"

  %% User auth
  USER ||--o{ ACCOUNT : "has accounts"
  USER ||--o{ SESSION : "has sessions"

  %% Projects
  USER ||--o{ PROJECT : "owns"
  USER ||--o{ USERPROJECT : "assigned to projects"
  PROJECT ||--o{ USERPROJECT : "has users"

  %% Tasks
  USER ||--o{ TASK : "creates (creator)"
  USER ||--o{ TASK : "assigned (assignee)"
  PROJECT ||--o{ TASK : "has tasks"

  %% Meetings (Task with type = MEETING)
  TASK ||--o{ MEETINGPARTICIPANT : "has participants"
  USER ||--o{ MEETINGPARTICIPANT : "attends"

  %% Time entries
  TASK ||--o{ TIMEENTRY : "has time entries"
  USER ||--o{ TIMEENTRY : "logs time"
</div></code></pre>
<p><strong>Főbb entitások</strong>:</p>
<ul>
<li><strong>User</strong>: Felhasználók, hierarchikus manager-employee kapcsolattal, szerepkör támogatással (EMPLOYEE, MANAGER role-ok)</li>
<li><strong>Account</strong>: OAuth provider fiókok (Google, Discord)</li>
<li><strong>Session</strong>: Felhasználói munkamenetek (JWT esetén nem használt)</li>
<li><strong>Project</strong>: Projektek kezdési és befejezési dátumokkal</li>
<li><strong>UserProject</strong>: Kapcsoló tábla felhasználók és projektek között (many-to-many)</li>
<li><strong>Task</strong>: Többcélú entitás - feladatok, megbeszélések, szabadságok, egyéni feladatok</li>
<li><strong>TimeEntry</strong>: Munkaidő bejegyzések feladatokhoz rendelve</li>
<li><strong>MeetingParticipant</strong>: Kapcsolótábla egy megbeszélés és résztvevői között</li>
</ul>
<h3 id="repository-r%C3%A9teg-data-access-layer">Repository réteg (Data Access Layer)</h3>
<p>A repository réteg biztosítja az adathozzáférési logikát. Minden entitáshoz tartozik egy repository, amely elrejti a Prisma specifikus implementációt.</p>
<p><strong>Felelősségek</strong>:</p>
<ul>
<li>CRUD műveletek implementálása</li>
<li>Adatbázis lekérdezések összeállítása</li>
<li>Kapcsolódó entitások betöltése (includes, relations)</li>
<li>Adatbázis hibák kezelése</li>
</ul>
<p><strong>Főbb repository-k</strong>:</p>
<ul>
<li><code>userRepository.ts</code> - Felhasználók kezelése</li>
<li><code>projectRepository.ts</code> - Projektek kezelése</li>
<li><code>taskRepository.ts</code> - Feladatok kezelése</li>
<li><code>timeEntryRepository.ts</code> - Munkaidő bejegyzések kezelése</li>
<li><code>userProjectRepository.ts</code> - Felhasználó-projekt kapcsolatok</li>
</ul>
<h3 id="service-r%C3%A9teg-business-logic-layer">Service réteg (Business Logic Layer)</h3>
<p><strong>Jelenlegi implementáció</strong>:</p>
<p>A Core Application esetében a service réteg <strong>jelenleg nincs külön kiválasztva</strong>, mivel az alkalmazás főként CRUD műveleteket végez, ahol az üzleti logika minimális. A legtöbb endpoint esetében a logika elsősorban <strong>validációból</strong> áll (pl. autentikáció ellenőrzés, jogosultság ellenőrzés, input validálás), amely közvetlenül az API rétegben van implementálva.</p>
<p><strong>Komplex üzleti logika elhelyezése</strong>:</p>
<p>A rendszer architektúrájában a jelentős üzleti logika a <strong>microservice-ekben</strong> található:</p>
<ul>
<li><strong>Communications Service</strong> (Elixir): Értesítési szabályok, email template generálás, Discord integráció logika</li>
<li><strong>Reporting Service</strong> (Python): Statisztikai számítások, riportgenerálás, adatelemzés</li>
</ul>
<p>A Core Application felelőssége ezért elsősorban:</p>
<ul>
<li>Adatok perzisztálása és lekérése</li>
<li>Felhasználói hitelesítés és jogosultságkezelés</li>
<li>Alapvető input validáció</li>
<li>microserviceek koordinálása REST API hívásokon keresztül</li>
</ul>
<p><strong>Jövőbeli fejlesztés</strong>: Amennyiben a Core Application-ben több komplex üzleti logika jelenne meg (pl. összetett munkaidő számítások, automatikus projekt értékelések), akkor érdemes lenne a service réteget kiemelni az API handler-ekből a jobb szeparáció és tesztelhetőség érdekében.</p>
<h3 id="api-r%C3%A9teg-route-handlers">API réteg (Route Handlers)</h3>
<p>Az API réteg (<code>/server/api/</code>) tartalmazza a HTTP végpontokat. Nuxt.js fájlrendszer alapú routing-ok használ, ahol a fájlstruktúra határozza meg az endpoint-okat.</p>
<p><strong>Felelősségek</strong>:</p>
<ul>
<li>HTTP kérések fogadása</li>
<li>Autentikáció és autorizáció ellenőrzése</li>
<li>Request validálás</li>
<li>Repositoryk hívása</li>
<li>Response formálása</li>
<li>HTTP státuszkódok kezelése</li>
</ul>
<h3 id="authentication-r%C3%A9teg">Authentication réteg</h3>
<p>Az autentikáció NextAuth (Auth.js) könyvtárral van implementálva (<code>/server/api/auth/[...].ts</code>).
Minden endpoint-ot csak bejelentkezett felhasználók érnek el. Az adott felhasználó jogosultsága validálva van az egyes kéréseknél. PL.: Task-ot csak a létrehozója törölhet</p>
<p><strong>Támogatott provider-ek</strong>:</p>
<ul>
<li>Google OAuth 2.0</li>
<li>Discord OAuth</li>
<li>Email-jelszó (Credentials Provider)</li>
</ul>
<p><strong>JWT munkamenet</strong>:</p>
<ul>
<li>Stateless session kezelés</li>
<li>Token tartalmazza: user id, email, name, role, image</li>
<li>Biztonságos titkosítás a NEXTAUTH_SECRET-tel</li>
</ul>
<h3 id="prezent%C3%A1ci%C3%B3s-r%C3%A9teg-frontend">Prezentációs réteg (Frontend)</h3>
<p>A frontend Vue.js komponensekből áll, Nuxt.js keretrendszerben (<code>/app/</code>). A komponensek reszponzívak, támogatják a sötét és világos témákat, ARIA attribútumokkal vannak ellátva a jobb hozzáférhetőség érdekében és TailwindCSS-el vannak dizájnolva.</p>
<p>A Nuxt a front-end is az apihoz hasonlóan fájlrendszer alapú routingot használ, így az oldalak könnyen megtalálhatók a könyvtárstruktúrában és a jobb SEO és teljesítmény érdekében server-side renderinget (SSR) alkalmaz front-end hydration-nel a dinamikus interakciókhoz.</p>
<p><strong>Komponensek</strong> (<code>/app/components/</code>):</p>
<ul>
<li><code>ProjectCard.vue</code> - Projekt megjelenítés</li>
<li><code>TimeAdministrationCard.vue</code> - Munkaidő adminisztráció lista elem</li>
<li><code>AddTimeEntryModal.vue</code> - Munkaidő rögzítés modal</li>
<li><code>TaskAssigneeModal.vue</code> - Feladat hozzárendelés modal</li>
<li>És további komponensek...</li>
</ul>
<p><strong>Oldalak</strong> (<code>/app/pages/</code>):</p>
<ul>
<li>
<p><code>login/</code> - Bejelentkezés</p>
<center>
</center><p><img src="file:///home/wingsmc/dev/bme/arch/docs/image-5.png" alt="login"></p>

</li>
<li>
<p><code>projects/</code> - Projekt menedzsment oldalak</p>
<center>
</center><p><img src="file:///home/wingsmc/dev/bme/arch/docs/image.png" alt="project lis"></p>
<p><img src="file:///home/wingsmc/dev/bme/arch/docs/image-1.png" alt="project details"></p>

</li>
<li>
<p><code>tasks/</code> - Feladat kezelés oldalak</p>
<center>
</center><p><img src="file:///home/wingsmc/dev/bme/arch/docs/image-2.png" alt="task details"></p>

</li>
<li>
<p><code>administration/</code> - Adminisztrációs felület</p>
<center>
</center><p><img src="file:///home/wingsmc/dev/bme/arch/docs/image-3.png" alt="administration"></p>

</li>
<li>
<p><code>approvals/</code> - Jóváhagyások</p>
<center>
</center><p><img src="file:///home/wingsmc/dev/bme/arch/docs/image-4.png" alt="approvals"></p>

</li>
<li>
<p><code>calendar/</code> - naptár nézet</p>
<center>
</center><p><img src="file:///home/wingsmc/dev/bme/arch/docs/image-6.png" alt="calendar"></p>

- &#xFA;j esem&#xE9;ny l&#xE9;trehoz&#xE1;sa
  <center>
</center><p><img src="file:///home/wingsmc/dev/bme/arch/docs/image-7.png" alt="create_new_event"></p>
  
- &#xFA;j meeting l&#xE9;trehoz&#xE1;sa
  <center>
</center><p><img src="file:///home/wingsmc/dev/bme/arch/docs/image-8.png" alt="create_new_meeting"></p>
<p><img src="file:///home/wingsmc/dev/bme/arch/docs/image-9.png" alt="create_new_meeting"></p>
<p><img src="file:///home/wingsmc/dev/bme/arch/docs/image-10.png" alt="create_new_meeting"></p>
  
- &#xFA;j szabads&#xE1;g l&#xE9;trehoz&#xE1;sa
  <center>
</center><p><img src="file:///home/wingsmc/dev/bme/arch/docs/image-11.png" alt="create_vacation"></p>
  
- a m&#xF3;dos&#xED;t&#xF3; fel&#xFC;leteken ugyanezek j&#xF6;nnek be, az adatok bet&#xF6;lt&#xE9;s&#xE9;vel:
  <center>
</center><p><img src="file:///home/wingsmc/dev/bme/arch/docs/image-12.png" alt="update_meeting"></p>
  
</li>
</ul>
<p><strong>Composable-ök</strong> (<code>/app/composables/</code>):</p>
<ul>
<li><code>useUser.ts</code> - A felhasználó adatainak session-ből kiolvasását könnyíti.</li>
</ul>
<p><strong>UI könyvtár</strong>: Nuxt UI komponensek TailwindCSS-el</p>
<ul>
<li>Sötét/világos téma támogatás</li>
<li>Reszponzív és szép design</li>
<li>Sok előre elkészített komponens</li>
</ul>
<p><strong>Naptár könyvtár</strong>: FullCalendar - robusztus és rugalmas naptárkönyvtár</p>
<ul>
<li>Többféle nézet: Támogatja a fő naptárnézeteket, mint a hónap, hét (időráccsal vagy anélkül), nap és a különböző lista nézetek</li>
<li>Interaktivitás: Támogatja az eseményekkel való interakciót (pl. drag and drop, kattintás).</li>
</ul>
<h3 id="r%C3%A9tegek-k%C3%B6z%C3%B6tti-kommunik%C3%A1ci%C3%B3">Rétegek közötti kommunikáció</h3>
<pre><code class="language-mermaid"><div class="mermaid">graph TD
    UI[Prezentációs réteg<br/>Vue komponensek]
    API[API réteg<br/>Route handlers]
    Auth[Authentication réteg<br/>NextAuth]
    Repo[Repository réteg<br/>Data Access]
    DB[(PostgreSQL<br/>Database)]

    UI -->|HTTP Request| API
    API -->|Authorize| Auth
    API -->|Query| Repo
    Repo -->|Prisma ORM| DB
    Auth --> |Prisma ORM| DB
</div></code></pre>
<p><strong>Elvek</strong>:</p>
<ul>
<li><strong>Separation of Concerns</strong>: Minden réteg egyetlen felelősséggel rendelkezik</li>
<li><strong>Dependency Direction</strong>: Fentről lefelé (UI → API → Service → Repository → DB)</li>
<li><strong>Abstraction</strong>: Minden réteg elrejti az implementációs részleteket</li>
<li><strong>Testability</strong>: Rétegek külön-külön unit tesztelhetők</li>
</ul>
<h2 id="microsevice-ek">Microsevice-ek</h2>
<p>A rendszer két különálló microserviceszel egészül ki, amelyek a Core Application-től függetlenül futnak és specifikus üzleti funkciókat látnak el.</p>
<h3 id="comms-szolg%C3%A1ltat%C3%A1s-%E2%80%93-elixirphoenix">Comms Szolgáltatás – (Elixir/Phoenix)</h3>
<h4 id="1-c%C3%A9l-%C3%A9s-hat%C3%B3k%C3%B6r">1. Cél és Hatókör</h4>
<ul>
<li>E‑mailek küldése üzleti események (feladat kiosztás, projekt státusz, szabadság kérés stb.) alapján.</li>
<li>Discord slash command / interaction kérések fogadása, validálása, aláírás ellenőrzése és válasz generálása.</li>
</ul>
<h4 id="2-f%C5%91-%C3%B6sszetev%C5%91k">2. Fő Összetevők</h4>
<h5 id="e%E2%80%91mail">E‑mail</h5>
<ul>
<li>Swoosh (<code>Comms.Mailer</code>) a küldéshez; konfiguráció <code>:comms</code> OTP alkalmazás alatt (pl. <code>smtp_from_email</code>).</li>
<li>Sablonok: <code>priv/templates/email/*.html.eex</code> – klasszikus <code>.eex</code>. Minden sablon a várt assign kommenttel indul (pl. <code># assigner: %{name: String, email: String}</code>).</li>
<li>Builder: <code>Comms.Notifications</code> modul állítja össze a <code>Swoosh.Email</code> struktúrát (from, to, subject, body). A body renderelést Phoenix sablonmotor végzi a megfelelő path alapján.</li>
</ul>
<h5 id="discord">Discord</h5>
<p>Mivel Elixirhez nem találtam jól karbantartott Discord könyvtárat, a beépített Req HTTP klienst használtam a Discord API hívásokhoz és a hivatalos JS könyvtár forráskódját tanulmányoztam a számunkra szükséges funkciók implementálásához.</p>
<ul>
<li>Router pipeline <code>:discord</code> és <code>CommsWeb.Plugs.VerifyDiscordSignature</code> plug a Discord aláírás ellenőrzéséhez (fejlécek: <code>X-Signature-Ed25519</code>, <code>X-Signature-Timestamp</code>).</li>
<li>Végpontok:
<ul>
<li><code>POST /discord/interactions</code> – slash command / component interactions.</li>
</ul>
</li>
</ul>
<h4 id="3-adat-%C3%A9s-sablonkezel%C3%A9s">3. Adat és Sablonkezelés</h4>
<ul>
<li>Sablonváltozók: közvetlenül a <code>render</code> híváskor kerülnek átadásra assign mapként; a sablonok végeznek interpolációt.</li>
<li>Discord válaszok: általában JSON payload a Discord API elvárásai szerint (type, data). A validáció a signature ellenőrzés és a parancs típus alapján történik.</li>
</ul>
<h4 id="4-folyamatok">4. Folyamatok</h4>
<h5 id="e%E2%80%91mail-k%C3%BCld%C3%A9s">E‑mail Küldés</h5>
<ol>
<li>HTTP POST érkezik egy dedikált értesítési végpontra (pl. <code>/notifications/vacation-request</code>).</li>
<li>Controller / action validálja a minimális mezőket (címzett, JWT, kontextus adatok).</li>
<li><code>Comms.Notifications</code> összeállítja a <code>Swoosh.Email</code> struktúrát: <code>from_email()</code> + dinamikus <code>to</code>.</li>
<li>Sablon render: <code>Phoenix.View.render(&quot;email/vacation_request.html&quot;, assigns)</code> – generált HTML a levél törzséhez.</li>
<li><code>Comms.Mailer.deliver(email)</code> → küldés. Hibánál visszatér <code>{:error, reason}</code>.</li>
</ol>
<h5 id="discord-interaction">Discord Interaction</h5>
<ol>
<li>Discord küld egy HTTP POST-ot az <code>interactions</code> végpontra, fejlécekben időbélyeg + aláírás.</li>
<li><code>VerifyDiscordSignature</code> plug hitelesíti (Ed25519).</li>
<li>Controller dekódolja a JSON-t; slash command név alapján routing / dispatch.</li>
<li>Válasz JSON: ack / ephemeral üzenet / follow‑up trigger.
<ul>
<li>Az ephemeral a discord kontextusában azt jelenti, hogy csak a releváns user látja az adott üzenetet</li>
</ul>
</li>
</ol>
<h5 id="discord-command-telep%C3%ADt%C3%A9s">Discord Command Telepítés</h5>
<p><code>mix discord.install_commands</code> futtatás:</p>
<ul>
<li>Ellenőrzi szükséges env változókat.</li>
<li>Küldi az upsert kérést a Discord API-hoz Req segítségével.
<ul>
<li>A Discordnak meg kell mondani, hogy milyen parancsokat szeretnénk regisztrálni, a teljes parancs definíciót JSON formátumban kell elküldeni a megfelelő végpontra, beleértve a parancs nevét, leírását, és a paramétereket.</li>
</ul>
</li>
<li>Siker / hiba logolás, hibánál.
<ul>
<li>A dockerizált környezetben a task az rpc parancson keresztül futtatható; illetve magától is megpróbál lefutni a docker container indításkor (ha a környezeti változók rendelkezésre állnak).</li>
</ul>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># Manuális futtatás docker konténerben</span>
docker <span class="hljs-built_in">exec</span> &lt;container&gt; /app/bin/comms rpc <span class="hljs-string">'Comms.Discord.Registrar.install_global_commands()'</span>
</div></code></pre>
<h4 id="5-hibakezel%C3%A9s">5. Hibakezelés</h4>
<ul>
<li>E‑mail: Swoosh visszatérési érték alapján döntés. Nincs automatikus retry vagy backoff – hiba esetén a hívó fél (felsőbb szolgáltatás) kezeli az újrapróbálkozást.</li>
<li>Discord: Signature hiba → 401 / 403; ismeretlen parancs → 400 egyszerű üzenettel; parse hiba → 422 JSON.</li>
<li>Mix task: env hiány esetén <code>Mix.raise</code>; API hiba esetén status + body megjelenítés.</li>
</ul>
<h4 id="6-biztons%C3%A1g">6. Biztonság</h4>
<ul>
<li>Discord aláírás ellenőrzés kötelező minden interakciónál. A Discord az endpoint regisztráció során küld több néhol direkt hibás PING kérést is, ezeket is ellenőrizni kell és a megfelelő hibakóddal válaszolni különben nem lesz sikeres a regisztráció.</li>
<li>E‑mail végpontok: asszimetrikus JWT alapú hitelesítés (RS256). A token tartalmazza a kezdeményező felhasználó azonosítóját és jogosultságait.</li>
<li>Sablonokban nincs futtatható kód injektálás: csak interpoláció a kapott assign értékekkel.</li>
</ul>
<h4 id="7-egyszer%C5%B1-metrik%C3%A1k--logok-aktu%C3%A1lis-%C3%A1llapot">7. Egyszerű Metrikák / Logok (Aktuális Állapot)</h4>
<ul>
<li>Strukturált log: siker / hiba e‑mail küldés, Discord parancs neve, státusz.</li>
</ul>
<h4 id="8-tesztek">8. Tesztek</h4>
<ul>
<li>Unit:
<ul>
<li><code>Comms.Notifications</code> – sablon renderelés különböző assign-ekkel, e‑mail struktúra ellenőrzése.</li>
<li>Discord signature plug test: hamis Discord signature → 403.</li>
</ul>
</li>
<li>Integrációs:
<ul>
<li>Health controller: egyszerű GET → 200 OK.</li>
<li>Discord interactions controller: ismert parancsok → várt válasz struktúra.</li>
</ul>
</li>
</ul>
<h3 id="reporting-service-python">Reporting Service (Python)</h3>
<p>A riportgeneráló szolgáltatás Python nyelven készült, adatelemzésre és statisztikák előállítására optimalizálva.
A feladata, hogy a Postgre adatbázisunkon elhelyezett aggregált view-k alapján jelentést készítsen az adott menedzserek projektjeiről, beosztottjairól.<br>
HTML-ben és PDF-ben generálja ki a jelentéseket, ezeket gRPC és REST végpontokon keresztül lehet lekérdezni.
A jelentések tartalmaznak szöveges adatokat, diagramokat, illetve táblázatokat, ezekre pár példa:</p>
<center>
</center><p><img src="file:///home/wingsmc/dev/bme/arch/docs/image-13.png" alt="report_diagrams">
<img src="file:///home/wingsmc/dev/bme/arch/docs/image-14.png" alt="report_tables"></p>

<p><strong>Felelősségek</strong>:</p>
<ul>
<li>Projekt előrehaladás riportok</li>
<li>Dolgozói teljesítmény összesítők</li>
<li>Exportálás különböző formátumokba</li>
<li>Adatvizualizáció (grafikonok, diagramok)</li>
</ul>
<p><strong>Működés</strong><br>
A szolgáltatás válaszidejének növelésének érdekében nem minden kérés alkalmával kerül végrehajtásra a szükséges adatok kinyerését szolgáló SQL lekérdezés, hanem előre definiált view-kból kérdez le az alkalmazás.
A view-k előre átgondolva, az ábrázolhatóságot figyelembe véve lettek megtervezve. Minden esetben a legfelső szinten a felhasználó id-ja szerint van csoportosítás, hiszen minden jelentés egy adott menedzser számára készül el.
A lekérdezett adatokból utána diagramokat készít a szoftver, ezeket png-ként elmenti egy temporális könyvtárba, hogy majd a riport generálásakor bele lehessen ágyazni őket.
A jelentés alapját egy .html kiterjesztésű template jelenti. Ebben a templateben a riportonként nem változó statikus szövegek mellett a későbbiekben kitöltendő változók, illetve css szabályok szerepelnek az igényes megjelenítést szolgálva. A sablon szövegekbe, táblázatokba beszúrásra kerülnek az adatbázisból kinyert adatok, illetve a base64 enkódolású képek (ezzel elérve, hogy beágyazottan, a ténylegesn png nélkül hordozható legyen a html fájl tartalma.). Ezen a ponton a jelentés készen is van, itt vagy megáll a folyamat, mivel a html végpont lett meghívva, vagy pedig pdf generálódik a html-ből. A végeredmény egy 3 oldalas pdf dokumentum, melyben az alábbi statisztikák szerepelnek:</p>
<ul>
<li>Menedzser alkalmazottjai által ledolgozott munkaórák hónapkonként</li>
<li>Menedzser alkalmazottjainak egyes projektekhez elkönyvelt munkaórái</li>
<li>Átlagos projekt időtartam</li>
<li>Projektek becsült és tényleges hossza közti eltérés</li>
<li>Projektekhez könyvelt munkaórák száma hónaponként</li>
<li>Alkalmazottak teljes munkaideje projektenkként</li>
</ul>
<p><strong>REST API végpontok</strong>:</p>
<ul>
<li><code>GET reports/manager/{manager_id}/pdf</code> - Adott id-val rendelkező menedzser riportját legenerálja, pdf-be kirendereli, majd application/pdf formátumban visszatér vele.</li>
<li><code>GET reports/manager/{manager_id}/html</code> - Adott id-val rendelkező menedzser riportjának a generálása html-ben, visszatérés vele.</li>
</ul>
<p><strong>gRPC végpontok</strong></p>
<ul>
<li><code>rpc GetManagerHTML</code> - Adott id-val rendelkező menedzser riportjának a generálása html-ben, visszatérés vele, egy string formájában.</li>
<li><code>rpc GetManager</code> - Adott id-val rendelkező menedzser riportjának a generálása pdf-ben, visszatérés vele base64-elt pdf formájában.</li>
<li><code>rpc GetAllReportsOfManager</code> - Előző két pont eredményeit egyben adja vissza</li>
<li><code>rpc GetAllManagerReports</code> - Az összes menedzser, összes jelentését visszaadja, egyéb metaadatokkal (pl.: a jelentésekben szereplő képek külön) együtt.</li>
</ul>
<h2 id="telep%C3%ADt%C3%A9si-le%C3%ADr%C3%A1s">Telepítési leírás</h2>
<h3 id="development">Development</h3>
<p>Az itt leírt eszközök természetesen dockerizált fejlesztési környezetben is használhatók.</p>
<ul>
<li>Javasolt:
<ul>
<li>Docker</li>
<li>Docker Compose</li>
<li><code>ngrok</code> vagy hasonló eszköz helyi szerverek publikus eléréséhez (Discord interactions endpoint teszteléséhez)</li>
<li><code>@antfu/ni</code> - node fejlesztői környezet menedzseléséhez</li>
</ul>
</li>
<li>Szükséges:
<ul>
<li>Node.js (ajánlott verzió: 22.x vagy újabb)
<ul>
<li>alterannatívaként használható Deno vagy Bun</li>
</ul>
</li>
<li>NPM (Node Package Manager, a Node.js telepítéssel együtt települ)</li>
<li>PNPM csomagkezelő
<ul>
<li>Telepítés: <code>npm install -g pnpm</code></li>
</ul>
</li>
<li>Erlang OTP (ajánlott verzió: 26.x vagy újabb)</li>
<li>Elixir (ajánlott verzió: 1.17.x vagy újabb)</li>
<li>Mix (Elixir build tool, az Elixir telepítéssel együtt települ)</li>
<li>Python (ajánlott verzió: 3.10 vagy újabb)</li>
<li>pip (Python csomagkezelő, a Python telepítéssel együtt települ)</li>
<li>Virtualenv (Python virtuális környezet menedzseléséhez)
<ul>
<li>Telepítés: <code>pip install virtualenv</code></li>
</ul>
</li>
<li>Visual Studio Code / Zed / nvim / bármilyen kedvenc kódszerkesztő ami támogatja a következő vagy hasonló bővítményeket:
<ul>
<li>Prettier: egységes kódformázáshoz</li>
<li>ESLint: kódminőség ellenőrzéshez</li>
<li>Tailwind IntelliSense: Tailwind osztályok automatikus kiegészítéséhez</li>
<li>Prisma</li>
<li>Vue (Official)</li>
<li>Python</li>
<li>ElixirLS</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>A core-app és a comms fejlesztéshez beolvas <code>.env</code> fájlokat. Bár a comms csak akkor, ha a dev-server.sh scriptet használod az indításhoz.</p>
<p>Minden projektben a saját dependenciáit a megfelelő csomagkezelővel kell telepíteni:</p>
<ul>
<li>Core Application (Nuxt.js): <code>pnpm install</code></li>
<li>Communications Service (Elixir/Phoenix): <code>mix deps.get</code></li>
<li>Reporting Service (Python): (előbb érdemes egy venv-et csinálni, lásd lejebb) <code>pip install -r requirements.txt</code></li>
</ul>
<p>Projekt struktúra:</p>
<pre class="hljs"><code><div>Gyökér
  ├── app                     <span class="hljs-comment"># Core Application (Nuxt.js)</span>
  ├── comms                   <span class="hljs-comment"># Communications Service (Elixir/Phoenix)</span>
  ├── reporting               <span class="hljs-comment"># Reporting Service (Python)</span>
  └── docker-compose.yml      <span class="hljs-comment"># Docker Compose (kitöltendő)</span>
</div></code></pre>
<center>
</center><p><strong>&lt;&lt; Minden ami a production előkészítéséhez szükséges &gt;&gt;</strong></p>

<h4 id="futtat%C3%A1s-fejleszt%C5%91i-m%C3%B3dban">Futtatás fejlesztői módban:</h4>
<h5 id="core-application">Core Application</h5>
<pre class="hljs"><code><div><span class="hljs-built_in">cd</span> app
pnpm run dev
</div></code></pre>
<h5 id="communications-service">Communications Service</h5>
<pre class="hljs"><code><div><span class="hljs-built_in">cd</span> comms
./dev-server.sh
</div></code></pre>
<h5 id="reporting-service">Reporting Service</h5>
<pre class="hljs"><code><div><span class="hljs-built_in">cd</span> reporting
<span class="hljs-comment"># Virtuális környezet létrehozása és aktiválása</span>
virtualenv venv
<span class="hljs-built_in">source</span> venv/bin/activate  <span class="hljs-comment"># Linux/MacOS</span>
venv\Scripts\activate     <span class="hljs-comment"># Windows</span>
<span class="hljs-comment"># Függőségek telepítése</span>
pip install -r requirements.txt
<span class="hljs-comment"># Fejlesztői szerver indítása</span>
python app.py
</div></code></pre>
<h4 id="adatb%C3%A1zis">Adatbázis</h4>
<p>A prisma automatikusan elvégzi a migrációkat és seedeli az adatbázist fejlesztői módban a <code>pnpm run dev</code> parancs futtatásakor. De, a prisma sutdio is használható az adatbázis böngészéséhez és manuális módosításához:</p>
<pre class="hljs"><code><div><span class="hljs-built_in">cd</span> app
pnpm run db:studio
</div></code></pre>
<p>Érdemes lehet a gyökérben és a core-app mappában található <code>package.json</code> fájlokban definiált futtatható parancsokat is megnézni. Illetve a dockerfile-okat, hogy hogyan épülnek a projektek production környezethez.</p>
<h3 id="production">Production</h3>
<p>Környezeti változók a docker-compose-hoz és fejlesztéshez:</p>
<h4 id="el%C5%91k%C3%A9sz%C3%BCletek">Előkészületek :</h4>
<ul>
<li>RSA kulcspár generálása JWT aláíráshoz (RS256) a gyökér mappában futtassuk:</li>
</ul>
<pre class="hljs"><code><div>pnpm run rsa:key-gen
pnpm run rsa:pub-key-gen
</div></code></pre>
<p>Vagy, ha nincs pnpm:</p>
<pre class="hljs"><code><div>ssh-keygen -t rsa -b 4096 -m PEM -f private.key
ssh-keygen -f private.key -e -m PKCS8 &gt; public.key
</div></code></pre>
<ul>
<li>Google OAuth
<ol>
<li>Google Cloud Console-ban hozz létre egy új projektet.</li>
<li>Engedélyezd az &quot;OAuth 2.0 Client IDs&quot; szolgáltatást.</li>
<li>Hozz létre egy új OAuth 2.0 kliensazonosítót webalkalmazás típusban.</li>
<li>Állítsd be a visszahívási URL-eket (pl. <code>http://localhost:3000/api/auth/callback/google</code>).</li>
</ol>
<ul>
<li><a href="https://developers.google.com/identity/protocols/oauth2/">https://developers.google.com/identity/protocols/oauth2/</a>]</li>
<li><a href="https://console.developers.google.com/">https://console.developers.google.com/</a></li>
</ul>
</li>
<li>Discord OAuth
<ol>
<li>Lépj be a Discord Developer Portal-ba.</li>
<li>Hozz létre egy új alkalmazást</li>
<li>Menj az &quot;OAuth2&quot; fülre, és állítsd be a redirect URI-ket (pl. <code>http://localhost:3000/api/auth/callback/discord</code>).</li>
</ol>
<ul>
<li><a href="https://discord.com/developers/docs/topics/oauth2">https://discord.com/developers/docs/topics/oauth2</a></li>
<li><a href="https://discord.com/developers/applications">https://discord.com/developers/applications</a></li>
</ul>
</li>
<li>Discord Bot / Interactions
<ol>
<li>A Discord Developer Portal-ban menj az alkalmazásod &quot;Bot&quot; fülére.</li>
<li>Klikkelj a Reset Token gombra, és jegyezd fel a token értékét.</li>
<li>Menj a &quot;General Information&quot; fülre, és jegyezd fel az &quot;Application ID&quot;-t és a &quot;Public Key&quot;-t.</li>
<li>Majd, ha fut a <code>comms</code> szolgáltatás PUBLIKUS URL-en (fejlesztéshez: <code>ngrok http 4000</code>), állítsd be az Interactions endpointot (pl. <code>https://your-public-domain.com/api/discord/interactions</code>)</li>
<li>Engedélyezd a szükséges jogosultságokat a bot számára az &quot;Installation&quot; fülön:
<ul>
<li>scopes: applications.commands, bot</li>
<li>permissions: Attach Files, Create Events, Embed Links, Manage Events, Send Messages</li>
</ul>
</li>
<li>Állítsd be, hogy a bot csak Guild (=szerver) installációval legyen elérhető.</li>
<li>Telepítsd a botot a szerveredre az &quot;Installation&quot; fül alatt látható URL segítségével, ami valahogy így néz ki: <code>https://discord.com/oauth2/authorize?client_id=YOUR_CLIENT_ID</code></li>
</ol>
</li>
</ul>
<h4 id="postgresql-adatb%C3%A1zis">PostgreSQL adatbázis:</h4>
<ul>
<li><code>POSTGRES_USER</code> - adatbázis felhasználónév</li>
<li><code>POSTGRES_PASSWORD</code> - adatbázis jelszó</li>
<li><code>POSTGRES_DB</code> - adatbázis név</li>
<li><code>POSTGRES_PORT</code> - adatbázis port (alapértelmezett: 5432)</li>
</ul>
<h4 id="coremigratorreporting-szolg%C3%A1ltat%C3%A1sok">Core/Migrator/Reporting szolgáltatások:</h4>
<ul>
<li><code>DATABASE_URL</code> - PostgreSQL adatbázis connection string (pl.: <code>postgresql://user:password@host:port/dbname?schema=workplanner</code>) a fentebbi értékek felhasználásával.</li>
</ul>
<h4 id="migrator">Migrator:</h4>
<ul>
<li><code>SEED_DB</code> - ha <code>true</code>, akkor a migráció után seedeli az adatbázist, alapértelmezett: <code>false</code>, elsősorban fejlesztéshez meg demozáshoz használatos.</li>
</ul>
<h4 id="core-application-nuxt">Core Application (Nuxt):</h4>
<ul>
<li><code>NUXT_AUTH_SECRET</code>: Az Auth.js használja aláíráshoz és titkosításhoz.</li>
<li><code>NUXT_AUTH_URL</code>: Az Auth.js callback URL-je. <code>http://localhost:3000/api/auth</code></li>
<li><code>NUXT_AUTH_ORIGIN</code>: A Core Application alap URL-je kéne, hogy legyen, de valamiért csak a <code>http://localhost:3000/api/auth</code> működik.</li>
<li><code>NUXT_COMMS_API_URL</code>: A communications microservice URL-je (pl. http://comms:4000)</li>
<li><code>NUXT_PUBLIC_REPORT_SERVICE_URL</code>: A reporting microservice PUBLIKUS URL-je (pl. http://localhost:8080)</li>
<li><code>NUXT_PUBLIC_REPORT_SERVICE_API_KEY</code>: A reporting microservice API kulcsa. Tetszőleges string, csak egyeznie kell a microservice-ben beállított értékkel. (pl. <code>eb791ef310f839e817cc0aac46f5883adea878e57f60472fba9d670ef74b2187</code>)</li>
<li><code>NUXT_JWT_PRIVATE_KEY</code>: RSA private key JWT aláíráshoz (RS256) a comms szolgáltatás felé küldött kérésekhez. A feljebb generált RSA private key tartalma. Ha a docker-composeban van ez megadva, akkor inline JSON string formátumban kell megadni (&quot;-----BEGIN....\n...\n-----END...&quot;) vagy többsoros formátumban idézőjelek nélkül.</li>
<li><code>NUXT_GOOGLE_CLIENT_ID</code>: A Google OAuth kliens azonosító.</li>
<li><code>NUXT_GOOGLE_CLIENT_SECRET</code>: A Google OAuth kliens titkos kulcsa.</li>
<li><code>NUXT_DISCORD_CLIENT_ID</code>: A Discord OAuth kliens azonosító.</li>
<li><code>NUXT_DISCORD_CLIENT_SECRET</code>: A Discord OAuth kliens titkos kulcsa.</li>
</ul>
<h4 id="communications-service-elixirphoenix">Communications Service (Elixir/Phoenix):</h4>
<ul>
<li><code>SECRET_KEY_BASE</code> - Phoenix alkalmazás titkos kulcsa (generálható: <code>mix phx.gen.secret</code>)</li>
<li><code>PHX_HOST</code> - Phoenix alkalmazás host neve (pl. <code>localhost</code> vagy <code>worktime-comms.yourdomain.com</code>)</li>
<li><code>DNS_CLUSTER_QUERY</code> - (opcionális) ha clustering-et használsz pl. Kubernetes-ben, akkor a DNS név, amin keresztül a node-ok megtalálják egymást (pl. <code>worktime-comms-headless.default.svc.cluster.local</code>)</li>
<li><code>JWT_PUBLIC_KEY</code> - A fenti privát kulcshoz tartozó publikus kulcs, JWT ellenőrzéshez (RS256) a core alkalmazás felől érkező kérésekhez. Ezt idézőjelek nélkül, többsoros formátumban kell megadni (yaml-ban pl. <code>|</code> vagy <code>&gt;</code> operátorral).</li>
<li><code>SMTP_SERVER</code> - SMTP szerver címe e‑mailek küldéséhez.</li>
<li><code>SMTP_PORT</code> - SMTP szerver portja (pl. 587 TLS-hez vagy 465 SSL-hez).</li>
<li><code>SMTP_USERNAME</code> - SMTP szerver felhasználónév.</li>
<li><code>SMTP_PASSWORD</code> - SMTP szerver jelszó.</li>
<li><code>SMTP_SSL</code> - ha <code>true</code>, akkor SSL kapcsolatot használ az SMTP szerverrel.</li>
<li><code>SMTP_TLS_VERIFY</code> - ha <code>true</code>, akkor TLS kapcsolat esetén ellenőrzi a szerver tanúsítványát.</li>
<li><code>CORE_SERVICE_HTTP</code> - A core alkalmazás URL-je (pl. http://core-app:3000) bizonyos discord querykhez szükséges adatok lekéréséhez.</li>
<li><code>CORE_SERVICE_PUBLIC_HTTP</code> - A core alkalmazás PUBLIKUS URL-je (pl. http://localhost:3000) email linkek generálásához.</li>
<li><code>DISCORD_APP_ID</code> - A Discord alkalmazás azonosítója.</li>
<li><code>DISCORD_PUBLIC_KEY</code> - A Discord alkalmazás publikus kulcsa az interakciók aláírás ellenőrzéséhez.</li>
<li><code>DISCORD_BOT_TOKEN</code> - A Discord bot tokenje az API hívásokhoz.</li>
</ul>
<h4 id="reporting-service-python">Reporting Service (Python):</h4>
<ul>
<li><code>API_KEY</code> - A reporting szolgáltatás API kulcsa. Tetszőleges string, csak egyeznie kell a core alkalmazásban beállított értékkel. (pl. <code>eb791ef310f839e817cc0aac46f5883adea878e57f60472fba9d670ef74b2187</code>)</li>
</ul>
<h3 id="deployment">Deployment</h3>
<p>A deployment Docker Compose segítségével történik. A <code>docker-compose.yml</code> fájl jó kiindulási alapot nyújt, de a környezeti változókat ki kell tölteni a fentiek alapján.</p>
<h4 id="futtat%C3%A1s-lok%C3%A1lisan-buildelt-image-ekkel">Futtatás lokálisan buildelt image-ekkel:</h4>
<pre class="hljs"><code><div>docker-compose up -d --build
</div></code></pre>
<h4 id="futtat%C3%A1s-docker-hubos-image-ekkel">Futtatás Docker Hubos image-ekkel:</h4>
<p>A compose fájl alapvetően buildelésre van beállítva, de az image sorok kikommentelésével és a build sorok eltávolításával használhatók a Docker Hub-on tárolt előre buildelt image-ek.</p>
<pre class="hljs"><code><div>docker-compose up
</div></code></pre>
<p><strong>Fontos megjegyzés</strong>: Ha szeretnéd a discord parancsokat használni, akkor a comms szolgáltatásnak elérhetőnek kell lennie egy publikus URL-en keresztül (pl. ngrok vagy valamilyen reverse proxy segítségével).</p>

</body>
</html>
